Приоритетные коллекции: Хранение и обработка данных ч.1

1. Зачем разные коллекции?

    - Способ обработки данных
    - Решаемые задачи
    В зависимости от того как хранятся данные в памяти, к ним может осуществлятся доступ в одном случае быстрее, в другом медленнее;
    В тоже время для разнах типов по разному осуществляется доступ, например, на чтение данных;
    То есть в каких-то случаях, например, будем часто использовать получение данных - хранить выгодно в одной структуре данных;
    А, например, если необходимо будет часто добавлять или удалять данные, в рамках нашей задачи, выгодно будет использовать другую структуру данных.
    Примерно для этого коллекции и нужны;
    Другой момент - это каким образом необходимо обрабатывать данные:
     - друг за другом
     - строго в соответствии с каким-либо приоритетом(например, от меньшего к большему)
     - в первую очередь нужно извлекать те данные, которые поступили в последнюю очередь (например, при обходе графов)
     - и тд.

2. LinkedList

    * lec3_1.java - LinkedList (add)

    Представляет собой двусвязный список.
    Сначала разберемся, что такое список вообще
    Список – гибкая структура данных, позволяющая легко менять свой размер. Элементы доступны для вставки или удаления в любой позиции.
    Список в контексте теории алгоритмов - это такая структура для которой известно что на текущем этапе и что на следующем этапе, следующий элемент знает что после него и т.д.
    Нет возможности напрямую обратиться к 10 элементу такого списка. 
    Нужно обратиться к 9, чтобы узнать 10, потом к 8, чтобы узнать 9 и т.д. до 1 элемента.
    Т.е. чтобы пройти в 10 элемент - нужно будет просмотреть все то, что было до него.
    Какие плюсы?
    Прежде, чем смотреть на LinkedList, посмотрим как массив размещается в памяти

    Массив
     
     STACK                                   HEAP
     |  |  | list |  |  |  |  |  |  |  |  ||  |  | * | * | * | * |  |  |  |  |  |
     определили переменную list - массив, и указали new int положив туда несколько элементов ****, для массива это ввсегда стандартно, эл-ты идут друг за другом
     но если речь идет о списке, данные могут располагаться где угодно

    Связный список

     STACK                                   HEAP
     |  |  | list |  |  |  |  |  |  |  |  ||  |  | * |  | * | * |  |  | * |  |  |
     но если речь идет о списке, данные могут располагаться где угодно; элемент знает о расположении следующего эл-такая 

    Массив
     Проблема добавления в массив

     STACK                                   HEAP
     |  |  | list |  |  |  |  |  |  |  |  ||  |  | d1 | d2 | d3 | v1 | v2 |  |  |  |  |
     list -> d1 d2 d3
     есть массив list с элементами d1, d2, d3. Нужно добавить еще элемент, но следующие ячейки памяти заняты другой программой(v1, v2)
     поэтому нужно будет определить новый участок памяти, скопировать туда элементы d1-d3, а затем заменить ссылку, а затем добавить d4
     STACK                                   HEAP
     |  |  | list |  |  |  |  |  |  |  |  ||  | d1 | d2 | d3 | v1 | v2 | d1 | d2 | d3 | d4 |  |
     list -> d1 d2 d3 d4

    Проблема удаления из массива

     STACK                                   HEAP
     |  |  | list |  |  |  |  |  |  |  |  ||  |  | d1 | d2 | d3 | d4 | d5 |  |  |  |  |
     list -> d1 d2 d3 d4 d5
     нужно удалить d2, классический метод со сдвигом следующего на место предыдущего до самого хвоста
     STACK                                   HEAP
     |  |  | list |  |  |  |  |  |  |  |  ||  |  | d1 | d3 | d4 | d5 | d5 |  |  |  |  |
     list -> d1 d3 d4 d5 d5
     перетащили, теперь нужно выделить новый участок памяти на один элемент меньше, потом произвести копирование элементов с d1 по d5, затем заменит ссылку
     STACK                                   HEAP
     |  |  | list |  |  |  |  |  |  |  |  ||  |  | d1 | d3 | d4 | d5 | d5 |  | d1 | d3 | d4 | d5 |  |  |
     list -> d1 d3 d4 d5

    Связный список
     Добавление в список.

     STACK                                   HEAP
     |  |  | list |  |  |  |  |  |  |  |  ||  |  | * | v1 | * | * | v2 | v3 | * |  |  |
     list -> * -> * -> * -> *
     появляются новые данные Т, которые нужно добавить в список после 2ого элемента
     STACK                                   HEAP
     |  |  | list |  |  |  |  |  |  |  |  ||  |  | d1 | v1 | d2 | d3 | v2 | v3 | d4 | T |  |
     list -> d1 -> d2 -> d3 -> d4
     list -> d1 -> d2 -> T -> d3 -> d4
     меняем ссылку с d2-d3 на d2-T, потом информацию из d2 мы переносим как сслыку(d2-d3) в Т, теперь Т знает где d3 (T-d3)

     Удаление из списка списка.

     STACK                                   HEAP
     |  |  | list |  |  |  |  |  |  |  |  ||  |  | d1 | v1 | d2 | d3 | v2 | v3 | d4 | T |  |
     list -> d1 -> d2 -> T -> d3 -> d4
     удаляем d3, то на что ссылался d3 (d3-d4) нужно положить в элемент, который ссылался на d3 (T-d3), то есть нужно подменить ссылку Т на d4
     в какой-то определенный момент, garbage collector удалит d3 из памяти, когда будет чистить мусор
     STACK                                   HEAP
     |  |  | list |  |  |  |  |  |  |  |  ||  |  | d1 | v1 | d2 |  | v2 | v3 | d4 | T |  |
     list -> d1 -> d2 -> T -> d4

        Чем такой способ организации лучше? Или хуже?
        Что нам с этого?
        Если часто удаляем и добавляем элементы лучше список
        Если постоянно считываем данные лучше массив 

        Количество операций меньше => скорость доступа к данным выше.
        Всегда ли? Доступ к элементу.

    Двусвязный список
     
     Знаем следующий и предыдущий элемент
      d1 <-> d2 <-> d3

      Структура данных, где информация хранится только о следующем элементе - односвязный список
      Структура данных, где информация хранится о прредыдущем и следующем - двусвязный список
      Односвязный список, в котором хранится информация, что идет после последнего элемента и это первый элемент - циклический односвязный список
      Двусвязный список, в кот. хранится информация, что идет после последнего эл-та и это первый эл-т, и перед первым идет последний - двунаправленный циклический список

    LinkedList имеет такой же функционал как List/ArrayList
    LinkedList нужен для небольшого количества элементов, в которых операции добавления\удаления встречаются чаще операций чтения.

3. Queue

    * lec3_2.java - LinkedList, Queue (add, remove, offer, peek)

    Кто первым пришел, тот будет первым обработан
    First in first out
    Очередь построена на LinkedList

    Queue<Integer> queue = new LinkedList<Integer>();
    queue.add(1);
    queue.add(2);
    queue.add(3);
    queue.add(4);
     |  |  | 1 | 2 |  | 3 |  |  | 4 |  |  

    int item = queue.remove(); удаляется тот элемент, который был в первуюочередь добавлен
     |  |  |  | 2 |  | 3 |  |  | 4 |  |
    queue.add(5);
     | 5 |  |  | 2 |  | 3 |  |  | 4 |  |
    queue.add(28);
     | 5 |  |  | 2 |  | 3 | 28 |  | 4 |  |

    Если извлекать эл-ты из очереди, а их там нет, будет исключение

    Иерархия коллекций:
        Queue: Deque(LinkedList, ArrayDeque), AbstractQueue(PriorityQueue)

4. PriorityQueue

    * lec3_4.java - PriorityQueue (add, poll)

    Наивысший приоритет имеет «наименьший» элемент.
    
    Для класической очереди извлекаем элементы в порядке их добавления
    В PriorityQueue тот элемент который меньше будет извлечен раньше.
    НО понятие меньший элемент для чисел понятно, а для строк? поэтому в таких случаях нужно описывать руками.

5. Deque - double ended queue

    * lec3_3.java - функционал Deque(addFirst, addLast, removeFirst, removeLast..), ArrayDeque

        deque.addFirst(1); // добавление в начало
        deque.addLast(2);  // добавление в конец
        deque.removeFirst(); // удаление из начала
        deque.removeLast(); // удаление с конца
        deque.offerFirst(25); // добавление в начало против порядка
        deque.offerLast(2); // добавление в конец против порядка
        deque.pollFirst(); // извлекает и удаляет первый элемент
        deque.pollLast(); // извлекает и удаляет второй элемент
        deque.getFirst(); // извлекает, но не удаляет, будет exeption если deque пустая 
        deque.getLast();
        deque.peekFirst();  // извлекает, но не удаляет, НЕ будет exeption если deque пустая
        deque.peekLast();

    Основной принцип, что данные можно добавлять как в начало так и в конец, 
    таким образом можно извлекать данные из начала и с конца
    Определение - Линейная коллекция, которая поддерживает вставку и удаление элементов на обоих концах. 

6. Stack

    * lec3_5.java - Вычислить значение выражения в постфиксной форме записи, Stack (pop, push), parseInt

    Работает по принципу - те данные, которые пришли раньше, будут обработаны в последнюю очередь
    First in - last out
    Альтернативой стеку может быть рекурсия, единственное когда рекурсия погружается в себя, она требует очень много ремурсов
    для стека столько ресурсов не требуется

    Иерархия коллекций:
    List: ArrayList, LinkedList, Vector(Stack)

    Stack представляет собой обработку данных по принципу LIFO.
    Расширяет Vector пятью операциями, которые позволяют рассматривать вектор как стек.
     push(E item)
     pop()

    Stack и Vector не рекомендованы к использованию, вместо них используют Deque

    инфексная форма записи - обычная 1+1
    префиксная ++1
    постфиксная 1++
    постфиксная и префиксная примерно одинаковые

    Stack
     Вычислить значение выражения в постфиксной форме записи
     1 + 2 * 3          (1 + 2) * 3  - инфексная форма
     1 2 3 * +           1 2 + 3 *   - постфиксная форма
     2 3 * +                            СТЕК -> СТЕК -> СТЕК -> СТЕК -> СТЕК
     3 * +                                1      2        3       6      7
     * +                                         1        2       1
     +                                                    1
     если встречается операция, то нужно взять два последних значения из стека, применить операцию, и результат положить в конец на место значений
